<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta name="robots" content="noindex,noarchive">
<title>Qt Toolkit - QScrollView Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 15%; text-indent: -15%; }
a:link { text-decoration: none; }
--></style>
</head><body bgcolor="#ffffff">

<a href=index.html><img width=122 height=65 src=qtlogo.jpg alt="Qt logo" align=left border=0></a>
<center><img src=dochead.gif width=472 height=27></center>
<br clear=all>

<h1 align=center>QScrollView Class Reference</h1><br clear="all">
<p>
The QScrollView widget provides a scrolling area with on-demand scrollbars.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qscrollview-h.html">qscrollview.h</a>&gt;</code>
<p>
Inherits <a href="qframe.html">QFrame</a>.
<p>Inherited by <a href="qlistview.html">QListView</a>.
<p><a href="qscrollview-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><span class="fn"><a href="qscrollview.html#a0"><strong>QScrollView</strong></a> ( QWidget * parent=0, const char * name=0, WFlags f=0 ) </span>
<li><span class="fn"><a href="qscrollview.html#a1"><strong>~QScrollView</strong></a> () </span>
<li><span class="fn">enum <strong><a name="ResizePolicy"></a>ResizePolicy</strong> { Default, Manual, AutoOne }</span>
<li><span class="fn">virtual void <a href="qscrollview.html#a2"><strong>setResizePolicy</strong></a> ( ResizePolicy ) </span>
<li><span class="fn">ResizePolicy <a href="qscrollview.html#a3"><strong>resizePolicy</strong></a> () const</span>
<li><span class="fn">void <a href="qscrollview.html#a4"><strong>addChild</strong></a> ( QWidget * child ) </span>
<li><span class="fn">void <a href="qscrollview.html#a5"><strong>removeChild</strong></a> ( QWidget * child ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#a6"><strong>addChild</strong></a> ( QWidget * child, int x, int y ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#a7"><strong>moveChild</strong></a> ( QWidget * child, int x, int y ) </span>
<li><span class="fn">int <a href="qscrollview.html#a8"><strong>childX</strong></a> ( QWidget * child ) </span>
<li><span class="fn">int <a href="qscrollview.html#a9"><strong>childY</strong></a> ( QWidget * child ) </span>
<li><span class="fn">bool <a href="qscrollview.html#b0"><strong>childIsVisible</strong></a> ( QWidget * child ) </span>
<li><span class="fn">void <a href="qscrollview.html#b1"><strong>showChild</strong></a> ( QWidget * child, bool yes=TRUE ) </span>
<li><span class="fn">enum <strong><a name="ScrollBarMode"></a>ScrollBarMode</strong> { Auto, AlwaysOff, AlwaysOn }</span>
<li><span class="fn">ScrollBarMode <a href="qscrollview.html#b2"><strong>vScrollBarMode</strong></a> () const</span>
<li><span class="fn">virtual void <a href="qscrollview.html#b3"><strong>setVScrollBarMode</strong></a> ( ScrollBarMode ) </span>
<li><span class="fn">ScrollBarMode <a href="qscrollview.html#b4"><strong>hScrollBarMode</strong></a> () const</span>
<li><span class="fn">virtual void <a href="qscrollview.html#b5"><strong>setHScrollBarMode</strong></a> ( ScrollBarMode ) </span>
<li><span class="fn">QWidget* <a href="qscrollview.html#b6"><strong>cornerWidget</strong></a> () const</span>
<li><span class="fn">virtual void <a href="qscrollview.html#b7"><strong>setCornerWidget</strong></a> ( QWidget * ) </span>
<li><span class="fn">QScrollBar* <a href="qscrollview.html#b8"><strong>horizontalScrollBar</strong></a> () </span>
<li><span class="fn">QScrollBar* <a href="qscrollview.html#b9"><strong>verticalScrollBar</strong></a> () </span>
<li><span class="fn">QWidget* <a href="qscrollview.html#c0"><strong>viewport</strong></a> () </span>
<li><span class="fn">int <a href="qscrollview.html#c1"><strong>contentsWidth</strong></a> () const</span>
<li><span class="fn">int <a href="qscrollview.html#c2"><strong>contentsHeight</strong></a> () const</span>
<li><span class="fn">int <a href="qscrollview.html#c3"><strong>contentsX</strong></a> () const</span>
<li><span class="fn">int <a href="qscrollview.html#c4"><strong>contentsY</strong></a> () const</span>
<li><span class="fn">void <a href="qscrollview.html#c5"><strong>resize</strong></a> ( int w, int h ) </span>
<li><span class="fn">void <a href="qscrollview.html#c6"><strong>resize</strong></a> ( const QSize &amp; ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#c7"><strong>show</strong></a> () </span>
</ul>
<h2>Public Slots</h2>
<ul>
<li><span class="fn">virtual void <a href="qscrollview.html#c9"><strong>resizeContents</strong></a> ( int w, int h ) </span>
<li><span class="fn">void <a href="qscrollview.html#d0"><strong>scrollBy</strong></a> ( int dx, int dy ) </span>
<li><span class="fn">void <a href="qscrollview.html#d1"><strong>setContentsPos</strong></a> ( int x, int y ) </span>
<li><span class="fn">void <a href="qscrollview.html#d2"><strong>ensureVisible</strong></a> ( int x, int y ) </span>
<li><span class="fn">void <a href="qscrollview.html#d3"><strong>ensureVisible</strong></a> ( int x, int y, int xmargin, int ymargin ) </span>
<li><span class="fn">void <a href="qscrollview.html#d4"><strong>center</strong></a> ( int x, int y ) </span>
<li><span class="fn">void <a href="qscrollview.html#d5"><strong>center</strong></a> ( int x, int y, float xmargin, float ymargin ) </span>
<li><span class="fn">void <a href="qscrollview.html#d6"><strong>updateScrollBars</strong></a> () </span>
</ul>
<h2>Signals</h2>
<ul>
<li><span class="fn">void <a href="qscrollview.html#c8"><strong>contentsMoving</strong></a> ( int x, int y ) </span>
</ul>
<h2>Protected Members</h2>
<ul>
<li><span class="fn">virtual void <a href="qscrollview.html#d7"><strong>resizeEvent</strong></a> ( QResizeEvent * ) </span>
<li><span class="fn">virtual bool <a href="qscrollview.html#d8"><strong>eventFilter</strong></a> ( QObject *, QEvent * e ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#d9"><strong>viewportPaintEvent</strong></a> ( QPaintEvent * ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#e0"><strong>viewportMousePressEvent</strong></a> ( QMouseEvent * ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#e1"><strong>viewportMouseReleaseEvent</strong></a> ( QMouseEvent * ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#e2"><strong>viewportMouseDoubleClickEvent</strong></a> ( QMouseEvent * ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#e3"><strong>viewportMouseMoveEvent</strong></a> ( QMouseEvent * ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#e4"><strong>drawContentsOffset</strong></a> ( QPainter *, int ox, int oy, int cx, int cy, int cw, int ch ) </span>
<li><span class="fn">virtual void <a href="qscrollview.html#e5"><strong>frameChanged</strong></a> () </span>
<li><span class="fn">void <a href="qscrollview.html#e6"><strong>setMargins</strong></a> ( int left, int top, int right, int bottom ) </span>
<li><span class="fn">int <a href="qscrollview.html#e7"><strong>leftMargin</strong></a> () const</span>
<li><span class="fn">int <a href="qscrollview.html#e8"><strong>topMargin</strong></a> () const</span>
<li><span class="fn">int <a href="qscrollview.html#e9"><strong>rightMargin</strong></a> () const</span>
<li><span class="fn">int <a href="qscrollview.html#f0"><strong>bottomMargin</strong></a> () const</span>
<li><span class="fn">virtual bool <a href="qscrollview.html#f1"><strong>focusNextPrevChild</strong></a> ( bool next ) </span>
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QScrollView widget provides a scrolling area with on-demand scrollbars.
<p>
The QScrollView is a large canvas - potentially larger than the coordinate
system normally supported by the underlying window system.  This is important,
as is is quite easy to go beyond such limitations (eg. many web pages are
more than 32000 pixels high).  Additionally, the QScrollView can have
QWidgets positioned on it that scroll around with the drawn content.  These
subwidgets can also have positions outside the normal coordinate range
(but they are still limited in size).
<p>Note that the scrolled area is the <a href="qscrollview.html#c0">viewport</a>() widget, not the QScrollView
itself.  So, to turn mouse tracking on for example, use
viewport()-><a href="qwidget.html#h5">setMouseTracking</a>(TRUE).  The only part of the QScrollView that
is visible is the "corner" and the frame.
<p>To provide content for the widget, inherit from QScrollView and
override <a href="qscrollview.html#e4">drawContentsOffset</a>(), and use <a href="qscrollview.html#c9">resizeContents</a>() to set
the size of the viewed area.  Use <a href="qscrollview.html#a4">addChild</a>(), <a href="qscrollview.html#a7">moveChild</a>(), and <a href="qscrollview.html#b1">showChild</a>()
to position widgets on the view.
<p>Note also the effect of <a href="qscrollview.html#a3">resizePolicy</a>().
<p><img src=qscrollview-m.gif> <img src=qscrollview-w.gif>

<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="a0"></a>QScrollView::QScrollView ( <a href="qwidget.html">QWidget</a> * parent=0, const char * name=0, WFlags f=0 )</h3>
<p>Constructs a QScrollView.
<p>If you intend to add child widgets, you may see improved refresh
if you include WPaintClever in the widgets flags, <em>f.</em>  WPaintClever
will be propagated to the <a href="qscrollview.html#c0">viewport</a>() widget.
<h3 class="fn"><a name="a1"></a>QScrollView::~QScrollView ()</h3>
<p>Destructs the QScrollView.  Any children added with <a href="qscrollview.html#a4">addChild</a>()
will be destructed.
<h3 class="fn">void <a name="a4"></a>QScrollView::addChild ( <a href="qwidget.html">QWidget</a> * child )</h3>
<p>Inserts <em>child</em> into the scrolled area.
It is equivalent to addChild(child,0,0).
<h3 class="fn">void <a name="a6"></a>QScrollView::addChild ( <a href="qwidget.html">QWidget</a> * child, int x, int y ) <code>[virtual]</code></h3>
<p>Inserts <em>child</em> into the scrolled area positioned at (<em>x, y).</em>
If the child is already in the view, it is just moved.
<h3 class="fn">int <a name="f0"></a>QScrollView::bottomMargin () const <code>[protected]</code></h3>
<p>Returns the current bottom margin.
<p>See also:  <a href="qscrollview.html#e6">setMargins</a>().
<h3 class="fn">void <a name="d4"></a>QScrollView::center ( int x, int y ) <code>[slot]</code></h3>
<p>Scrolls the content so that the point (x,y) is in the
center of visible area.
<h3 class="fn">void <a name="d5"></a>QScrollView::center ( int x, int y, float xmargin, float ymargin ) <code>[slot]</code></h3>
<p>Scrolls the content so that the point (x,y) is visible,
with the given margins (as fractions of visible area).
<p>eg.
<ul>
<li>Margin 0.0 allows (x,y) to be on edge of visible area.
<li>Margin 0.5 ensures (x,y) is in middle 50% of visible area.
<li>Margin 1.0 ensures (x,y) is in the center of the visible area.
</ul>
<h3 class="fn">bool <a name="b0"></a>QScrollView::childIsVisible ( <a href="qwidget.html">QWidget</a> * child )</h3>
<p>\obsolete
<p>Returns TRUE if <em>child</em> is visible.  This is equivalent
to child-><a href="qwidget.html#k6">isVisible</a>().
<h3 class="fn">int <a name="a8"></a>QScrollView::childX ( <a href="qwidget.html">QWidget</a> * child )</h3>
<p>Returns the X position of the given child widget.
Use this rather than <a href="qwidget.html#b5">QWidget::x</a>() for widgets added to the view.
<h3 class="fn">int <a name="a9"></a>QScrollView::childY ( <a href="qwidget.html">QWidget</a> * child )</h3>
<p>Returns the Y position of the given child widget.
Use this rather than <a href="qwidget.html#b6">QWidget::y</a>() for widgets added to the view.
<h3 class="fn">int <a name="c2"></a>QScrollView::contentsHeight () const</h3>
<p>Returns the height of the contents area.
<h3 class="fn">void <a name="c8"></a>QScrollView::contentsMoving ( int x, int y ) <code>[signal]</code></h3>
<p>This signal is emitted just before the contents is moved
to the given position.
<p>See also:  <a href="qscrollview.html#c3">contentsX</a>() and <a href="qscrollview.html#c4">contentsY</a>().
<h3 class="fn">int <a name="c1"></a>QScrollView::contentsWidth () const</h3>
<p>Returns the width of the contents area.
<h3 class="fn">int <a name="c3"></a>QScrollView::contentsX () const</h3>
<p>Returns the X coordinate of the contents which is at the left
edge of the viewport.
<h3 class="fn">int <a name="c4"></a>QScrollView::contentsY () const</h3>
<p>Returns the Y coordinate of the contents which is at the top
edge of the viewport.
<h3 class="fn"><a href="qwidget.html">QWidget</a>* <a name="b6"></a>QScrollView::cornerWidget () const</h3>
<p>Returns the widget in the corner between the two scrollbars.
<p>By default, no corner widget is present.
<h3 class="fn">void <a name="e4"></a>QScrollView::drawContentsOffset ( <a href="qpainter.html">QPainter</a> * p, int offsetx, int offsety, int clipx, int clipy, int clipw, int cliph ) <code>[virtual protected]</code></h3>
<p>Reimplement this method if you are viewing a drawing area rather
than a widget.
<p>Draws the rectangle (<em>clipx, clipy, clipw, cliph</em> ) of the
contents, offset by (<em>offsetx, offsety</em> ) using painter <em>p.</em>
All four are given in the scroll views's coordinates.  All of
<em>clipx, clipy, offsetx</em> and <em>offsety</em> are typically large
positive numbers.
<p>Note that the final coordinates you give to <a href="qpainter.html">QPainter</a> methods must be
within the range supported by the underlying window systems - about
+/- 32000 at most, often much less - +/- 4000 or so is all you should
really expect.
<p>For example:
<pre>  {
    // Fill a 40000 by 50000 rectangle at (100000,150000)

    // Calculate the coordinates... (don't use QPoint, QRect, etc!)
    int x1 = 100000, y1 = 150000;
    int x2 = x1+40000-1, y2 = y1+50000-1;

    // Clip the coordinates so X/Windows will not have problems...
    if (x1 &lt; clipx) x1=clipx;
    if (y1 &lt; clipy) y1=clipy;
    if (x2 &gt; clipx+clipw-1) x2=clipx+clipw-1;
    if (y2 &gt; clipy+cliph-1) y2=clipy+cliph-1;

    // Translate to scrolled coordinates...
    x1 -= ox;
    x2 -= ox;
    y1 -= oy;
    y2 -= oy;

    // Paint using the new small coordinates...
    if ( x2 &gt;= x1 &amp;&amp; y2 &gt;= y1 )
        p-&gt;fillRect(x1, y1, x2-x1+1, y2-y1+1, red);
  }
</pre>
<p>The clip rectangle of the painter <em>p</em> is already set appropriately.
<p>Note that <a href="qpainter.html#f2">QPainter::translate</a>() is not sufficient.
<p>The default implementation does nothing.
<p>Reimplemented in <a href="qlistview.html#g0">QListView</a>.
<h3 class="fn">void <a name="d2"></a>QScrollView::ensureVisible ( int x, int y ) <code>[slot]</code></h3>
<p>Scrolls the content so that the point (x, y) is visible
with at least 50-pixel margins (if possible, otherwise centered).
<h3 class="fn">void <a name="d3"></a>QScrollView::ensureVisible ( int x, int y, int xmargin, int ymargin ) <code>[slot]</code></h3>
<p>Scrolls the content so that the point (x, y) is visible
with at least the given pixel margins (if possible, otherwise centered).
<h3 class="fn">bool <a name="d8"></a>QScrollView::eventFilter ( <a href="qobject.html">QObject</a> * obj, <a href="qevent.html">QEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>This event filter ensures the scrollbars are updated when a single
contents widget is resized, shown, hidden, or destroyed, and passes
mouse events to the QScrollView.
<p>Reimplemented from <a href="qobject.html#a3">QObject.</a>
<h3 class="fn">bool <a name="f1"></a>QScrollView::focusNextPrevChild ( bool next ) <code>[virtual protected]</code></h3>
<p>Override so that traversal moves among child widgets, even if they
are not visible, scrolling to make them so.
<p>Reimplemented from <a href="qwidget.html#q3">QWidget.</a>
<h3 class="fn">void <a name="e5"></a>QScrollView::frameChanged () <code>[virtual protected]</code></h3>
<p>An override - ensures scrollbars are correct size when frame style changes.
<p>Reimplemented from <a href="qframe.html#c1">QFrame.</a>
<h3 class="fn">QScrollView::ScrollBarMode <a name="b4"></a>QScrollView::hScrollBarMode() const</h3>
<p>Returns the currently set mode for the horizontal scrollbar.
<p>See also:  <a href="qscrollview.html#b5">setHScrollBarMode</a>().
<h3 class="fn"><a href="qscrollbar.html">QScrollBar</a>* <a name="b8"></a>QScrollView::horizontalScrollBar ()</h3>
<p>Returns the component horizontal scrollbar.  It is made available to allow
accelerators, autoscrolling, etc., and to allow changing
of arrow scrollrates: bar->setSteps( rate, bar->pageStep() ).
<p>It should not be otherwise manipulated.
<h3 class="fn">int <a name="e7"></a>QScrollView::leftMargin () const <code>[protected]</code></h3>
<p>Returns the current left margin.
<p>See also:  <a href="qscrollview.html#e6">setMargins</a>().
<h3 class="fn">void <a name="a7"></a>QScrollView::moveChild ( <a href="qwidget.html">QWidget</a> * child, int x, int y ) <code>[virtual]</code></h3>
<p>Repositions <em>child</em> to (<em>x, y).</em>
This functions the same as <a href="qscrollview.html#a4">addChild</a>().
<h3 class="fn">void <a name="a5"></a>QScrollView::removeChild ( <a href="qwidget.html">QWidget</a> * child )</h3>
<p>Removes a child from the scrolled area.  Note that this happens
automatically if the child is deleted.
<h3 class="fn">void <a name="c6"></a>QScrollView::resize ( const <a href="qsize.html">QSize</a> &amp; s )</h3>
<p>An override - ensures scrollbars are correct size upon resize.
<h3 class="fn">void <a name="c5"></a>QScrollView::resize ( int w, int h )</h3>
<p>An override - ensures scrollbars are correct size upon resize.
<h3 class="fn">void <a name="c9"></a>QScrollView::resizeContents ( int w, int h ) <code>[virtual slot]</code></h3>
<p>Set the size of the contents area to <em>w</em> pixels wide and <em>h</em>
pixels high, and updates the viewport accordingly.
<h3 class="fn">void <a name="d7"></a>QScrollView::resizeEvent ( <a href="qresizeevent.html">QResizeEvent</a> * event ) <code>[virtual protected]</code></h3>
<p>An override - ensures scrollbars are correct size upon resize.
<p>Reimplemented from <a href="qwidget.html#o6">QWidget.</a>
<h3 class="fn">QScrollView::ResizePolicy <a name="a3"></a>QScrollView::resizePolicy() const</h3>
<p>Returns the currently set <a href="qscrollview.html#a2">ResizePolicy</a>.
<h3 class="fn">int <a name="e9"></a>QScrollView::rightMargin () const <code>[protected]</code></h3>
<p>Returns the current right margin.
<p>See also:  <a href="qscrollview.html#e6">setMargins</a>().
<h3 class="fn">void <a name="d0"></a>QScrollView::scrollBy ( int dx, int dy ) <code>[slot]</code></h3>
<p>Scrolls the content by <em>x</em> to the left and <em>y</em> upwards.
<h3 class="fn">void <a name="d1"></a>QScrollView::setContentsPos ( int x, int y ) <code>[slot]</code></h3>
<p>Scrolls the content so that the point (x, y) is in the top-left corner.
<h3 class="fn">void <a name="b7"></a>QScrollView::setCornerWidget ( <a href="qwidget.html">QWidget</a> * corner ) <code>[virtual]</code></h3>
<p>Sets the widget in the corner between the two scrollbars.
<p>You will probably also want to
set at least one of the scrollbar modes to AlwaysOn.
<p>Passing 0 shows no widget in the corner.
<p>Any previous corner widget is hidden.
<p>You may call setCornerWidget() with the same widget at different times.
<p>All widgets set here will be deleted by the QScrollView when it destructs
unless you seperately
recreate the widget after setting some other corner widget (or 0).
<p>Any <em>newly</em> set widget should have no current parent.
<p>By default, no corner widget is present.
<p>See also:  <a href="qscrollview.html#b3">setVScrollBarMode</a>() and <a href="qscrollview.html#b5">setHScrollBarMode</a>().
<h3 class="fn">void <a name="b5"></a>QScrollView::setHScrollBarMode ( ScrollBarMode mode ) <code>[virtual]</code></h3>
<p>Sets the mode for the horizontal scrollbar.
<ul>
<li> <code>Auto</code> (the default) shows a scrollbar when the content is too wide to fit.
<li> <code>AlwaysOff</code> never shows a scrollbar.
<li> <code>AlwaysOn</code> always shows a scrollbar.
</ul>
<p>See also:  <a href="qscrollview.html#b4">hScrollBarMode</a>() and <a href="qscrollview.html#b3">setVScrollBarMode</a>().
<h3 class="fn">void <a name="e6"></a>QScrollView::setMargins ( int left, int top, int right, int bottom ) <code>[protected]</code></h3>
<p>Sets the margins around the scrolling area.  This is useful for applications
such as spreadsheets with `locked' rows and columns.  The marginal space
is <em>inside</em> the <a href="qframe.html#b3">frameRect</a>() and is left blank - override <a href="qframe.html#c0">drawContents</a>()
or put widgets in the unused area.
<p>By default all margins are zero.
<p>See also:  <a href="qscrollview.html#e5">frameChanged</a>().
<h3 class="fn">void <a name="a2"></a>QScrollView::setResizePolicy ( ResizePolicy r ) <code>[virtual]</code></h3>
<p>Sets the resize policy to <em>r.</em>
<p>The policies are:
<ul>
<li> <code>Default</code> is the initial value.  It converts to <code>Manual</code> if
the view is resized with <a href="qscrollview.html#c9">resizeContents</a>(), or to <code>AutoOne</code>
if a child is added.
<li> <code>Manual</code> means the view stays the size set by resizeContents().
<li> <code>AutoOne</code> means that if there is only only child widget, the
view stays the size of that widget.
</ul>
<h3 class="fn">void <a name="b3"></a>QScrollView::setVScrollBarMode ( ScrollBarMode mode ) <code>[virtual]</code></h3>
<p>Sets the mode for the vertical scrollbar.
<p><ul>
<li> <code>Auto</code> (the default) shows a scrollbar when the content is too tall to fit.
<li> <code>AlwaysOff</code> never shows a scrollbar.
<li> <code>AlwaysOn</code> always shows a scrollbar.
</ul>
<p>See also:  <a href="qscrollview.html#b2">vScrollBarMode</a>() and <a href="qscrollview.html#b5">setHScrollBarMode</a>().
<h3 class="fn">void <a name="c7"></a>QScrollView::show () <code>[virtual]</code></h3>
<p>An override - ensures scrollbars are correct size upon showing.
<p>Reimplemented from <a href="qwidget.html#k2">QWidget.</a>
<h3 class="fn">void <a name="b1"></a>QScrollView::showChild ( <a href="qwidget.html">QWidget</a> * child, bool y=TRUE )</h3>
<p>\obsolete
<p>Sets the visibility of <em>child.</em> Equivalent to
<a href="qwidget.html#k2">QWidget::show</a>() or <a href="qwidget.html#k3">QWidget::hide</a>().
<h3 class="fn">int <a name="e8"></a>QScrollView::topMargin () const <code>[protected]</code></h3>
<p>Returns the current top margin.
<p>See also:  <a href="qscrollview.html#e6">setMargins</a>().
<h3 class="fn">void <a name="d6"></a>QScrollView::updateScrollBars () <code>[slot]</code></h3>
<p>Updates scrollbars - all possibilities considered.  You should never
need to call this in your code.
<h3 class="fn">QScrollView::ScrollBarMode <a name="b2"></a>QScrollView::vScrollBarMode() const</h3>
<p>Returns the currently set mode for the vertical scrollbar.
<p>See also:  <a href="qscrollview.html#b3">setVScrollBarMode</a>().
<h3 class="fn"><a href="qscrollbar.html">QScrollBar</a>* <a name="b9"></a>QScrollView::verticalScrollBar ()</h3>
<p>Returns the component vertical scrollbar.  It is made available to allow
accelerators, autoscrolling, etc., and to allow changing
of arrow scrollrates: bar->setSteps( rate, bar->pageStep() ).
<p>It should not be otherwise manipulated.
<h3 class="fn"><a href="qwidget.html">QWidget</a>* <a name="c0"></a>QScrollView::viewport ()</h3>
<p>Returns the viewport widget of the scrollview.  This is the widget
containing the contents widget or which is the drawing area.
<h3 class="fn">void <a name="e2"></a>QScrollView::viewportMouseDoubleClickEvent ( <a href="qmouseevent.html">QMouseEvent</a> * ) <code>[virtual protected]</code></h3>
<p>To provide simple processing of events on the contents,
this method receives all mouse
double click events sent to the viewport.
<h3 class="fn">void <a name="e3"></a>QScrollView::viewportMouseMoveEvent ( <a href="qmouseevent.html">QMouseEvent</a> * ) <code>[virtual protected]</code></h3>
<p>To provide simple processing of events on the contents,
this method receives all mouse
move events sent to the viewport.
<h3 class="fn">void <a name="e0"></a>QScrollView::viewportMousePressEvent ( <a href="qmouseevent.html">QMouseEvent</a> * ) <code>[virtual protected]</code></h3>
<p>To provide simple processing of events on the contents, this method receives all mouse
press events sent to the viewport.
<h3 class="fn">void <a name="e1"></a>QScrollView::viewportMouseReleaseEvent ( <a href="qmouseevent.html">QMouseEvent</a> * ) <code>[virtual protected]</code></h3>
<p>To provide simple processing of events on the contents,
this method receives all mouse
release events sent to the viewport.
<h3 class="fn">void <a name="d9"></a>QScrollView::viewportPaintEvent ( <a href="qpaintevent.html">QPaintEvent</a> * pe ) <code>[virtual protected]</code></h3>
<p>This is a low-level painting routine that draws the viewport
contents.  Override this if <a href="qscrollview.html#e4">drawContentsOffset</a>() is too high-level.
(for example, if you don't want to open a <a href="qpainter.html">QPainter</a> on the viewport).
<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses 
<a href="http://www.troll.no">www.troll.no</a>):<br>
<form method=post action="http://www.troll.no/search.cgi">
<input type=hidden name="version" value="1.44"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-99
<a href="troll.html">Troll Tech</a>, all rights reserved.
<p>
It was generated from the following files:
<ul>
<li>qscrollview.h: 1998/10/01
<li>qscrollview.cpp: 1998/11/20
</ul>
<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 1999 Troll Tech<td><a href="trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 1.45</div>
</table></div></address></body></html>
