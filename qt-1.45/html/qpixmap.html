<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta name="robots" content="noindex,noarchive">
<title>Qt Toolkit - QPixmap Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 15%; text-indent: -15%; }
a:link { text-decoration: none; }
--></style>
</head><body bgcolor="#ffffff">

<a href=index.html><img width=122 height=65 src=qtlogo.jpg alt="Qt logo" align=left border=0></a>
<center><img src=dochead.gif width=472 height=27></center>
<br clear=all>

<h1 align=center>QPixmap Class Reference</h1><br clear="all">
<p>
The QPixmap class is an off-screen pixel-based paint device.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qpixmap-h.html">qpixmap.h</a>&gt;</code>
<p>
Inherits <a href="qpaintdevice.html">QPaintDevice</a>.
<p>Inherited by <a href="qbitmap.html">QBitmap</a>.
<p><a href="qpixmap-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><span class="fn"><a href="qpixmap.html#a0"><strong>QPixmap</strong></a> () </span>
<li><span class="fn"><a href="qpixmap.html#a1"><strong>QPixmap</strong></a> ( int w, int h, int depth=-1 ) </span>
<li><span class="fn"><a href="qpixmap.html#a2"><strong>QPixmap</strong></a> ( const QSize &amp;, int depth=-1 ) </span>
<li><span class="fn"><a href="qpixmap.html#a3"><strong>QPixmap</strong></a> ( const char * fileName, const char * format=0, ColorMode mode=Auto ) </span>
<li><span class="fn"><a href="qpixmap.html#a4"><strong>QPixmap</strong></a> ( const char * fileName, const char * format, int conversion_flags ) </span>
<li><span class="fn"><a href="qpixmap.html#a5"><strong>QPixmap</strong></a> ( const char * xpm[] ) </span>
<li><span class="fn"><a href="qpixmap.html#a6"><strong>QPixmap</strong></a> ( const QPixmap &amp; ) </span>
<li><span class="fn"><a href="qpixmap.html#a7"><strong>~QPixmap</strong></a> () </span>
<li><span class="fn">QPixmap&amp; <a href="qpixmap.html#a8"><strong>operator=</strong></a> ( const QPixmap &amp; ) </span>
<li><span class="fn">QPixmap&amp; <a href="qpixmap.html#a9"><strong>operator=</strong></a> ( const QImage &amp; ) </span>
<li><span class="fn">bool <a href="qpixmap.html#b0"><strong>isNull</strong></a> () const</span>
<li><span class="fn">int <a href="qpixmap.html#b1"><strong>width</strong></a> () const</span>
<li><span class="fn">int <a href="qpixmap.html#b2"><strong>height</strong></a> () const</span>
<li><span class="fn">QSize <a href="qpixmap.html#b3"><strong>size</strong></a> () const</span>
<li><span class="fn">QRect <a href="qpixmap.html#b4"><strong>rect</strong></a> () const</span>
<li><span class="fn">int <a href="qpixmap.html#b5"><strong>depth</strong></a> () const</span>
<li><span class="fn">void <a href="qpixmap.html#b7"><strong>fill</strong></a> ( const QColor &amp; fillColor=white ) </span>
<li><span class="fn">void <a href="qpixmap.html#b8"><strong>fill</strong></a> ( const QWidget *, int xofs, int yofs ) </span>
<li><span class="fn">void <a href="qpixmap.html#b9"><strong>fill</strong></a> ( const QWidget *, const QPoint &amp; ofs ) </span>
<li><span class="fn">void <a href="qpixmap.html#c0"><strong>resize</strong></a> ( int width, int height ) </span>
<li><span class="fn">void <a href="qpixmap.html#c1"><strong>resize</strong></a> ( const QSize &amp; ) </span>
<li><span class="fn">const QBitmap* <a href="qpixmap.html#c2"><strong>mask</strong></a> () const</span>
<li><span class="fn">void <a href="qpixmap.html#c3"><strong>setMask</strong></a> ( const QBitmap &amp; ) </span>
<li><span class="fn">bool <a href="qpixmap.html#c4"><strong>selfMask</strong></a> () const</span>
<li><span class="fn">QBitmap <a href="qpixmap.html#c5"><strong>createHeuristicMask</strong></a> ( bool clipTight = TRUE ) const</span>
<li><span class="fn">QPixmap <a href="qpixmap.html#c7"><strong>xForm</strong></a> ( const QWMatrix &amp; ) const</span>
<li><span class="fn">QImage <a href="qpixmap.html#c9"><strong>convertToImage</strong></a> () const</span>
<li><span class="fn">bool <a href="qpixmap.html#d0"><strong>convertFromImage</strong></a> ( const QImage &amp;, ColorMode mode=Auto ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d1"><strong>convertFromImage</strong></a> ( const QImage &amp;, int conversion_flags ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d3"><strong>load</strong></a> ( const char * fileName, const char * format=0, ColorMode mode=Auto ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d4"><strong>load</strong></a> ( const char * fileName, const char * format, int conversion_flags ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d5"><strong>loadFromData</strong></a> ( const uchar * buf, uint len, const char * format=0, ColorMode mode=Auto ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d6"><strong>loadFromData</strong></a> ( const uchar * buf, uint len, const char * format, int conversion_flags ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d7"><strong>loadFromData</strong></a> ( QByteArray data, const char * format=0, int conversion_flags=0 ) </span>
<li><span class="fn">bool <a href="qpixmap.html#d8"><strong>save</strong></a> ( const char * fileName, const char * format ) const</span>
<li><span class="fn">int <a href="qpixmap.html#d9"><strong>serialNumber</strong></a> () const</span>
<li><span class="fn">Optimization <a href="qpixmap.html#e0"><strong>optimization</strong></a> () const</span>
<li><span class="fn">void <a href="qpixmap.html#e1"><strong>setOptimization</strong></a> ( Optimization ) </span>
<li><span class="fn">virtual void <a href="qpixmap.html#e4"><strong>detach</strong></a> () </span>
<li><span class="fn">bool <a href="qpixmap.html#e5"><strong>isQBitmap</strong></a> () const</span>
</ul>
<h2>Static Public Members</h2>
<ul>
<li><span class="fn">int <a href="qpixmap.html#f6"><strong>defaultDepth</strong></a> () </span>
<li><span class="fn">QPixmap <a href="qpixmap.html#g3"><strong>grabWindow</strong></a> ( WId, int x=0, int y=0, int w=-1, int h=-1 ) </span>
<li><span class="fn">QWMatrix <a href="qpixmap.html#g4"><strong>trueMatrix</strong></a> ( const QWMatrix &amp;, int w, int h ) </span>
<li><span class="fn">const char* <a href="qpixmap.html#f3"><strong>imageFormat</strong></a> ( const char * fileName ) </span>
<li><span class="fn">Optimization <a href="qpixmap.html#f7"><strong>defaultOptimization</strong></a> () </span>
<li><span class="fn">void <a href="qpixmap.html#f8"><strong>setDefaultOptimization</strong></a> ( Optimization ) </span>
</ul>
<h2>Protected Members</h2>
<ul>
<li><span class="fn"><a href="qpixmap.html#e6"><strong>QPixmap</strong></a> ( int w, int h, const uchar * data, bool isXbitmap ) </span>
<li><span class="fn">virtual int <a href="qpixmap.html#e7"><strong>metric</strong></a> ( int ) const</span>
</ul>
<h2>Related Functions</h2>
(Note that these are not member functions.)
<ul>
<li>QDataStream &amp; <a href="qpixmap.html#f4"><strong>operator&lt;&lt;</strong></a> (QDataStream &amp; s, const QPixmap &amp; pixmap)
<li>QDataStream &amp; <a href="qpixmap.html#f5"><strong>operator&gt;&gt;</strong></a> (QDataStream &amp; s, QPixmap &amp; pixmap)
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QPixmap class is an off-screen pixel-based paint device.
<p>
It is one of the two classes Qt provides for dealing with images,
the other being <a href="qimage.html">QImage</a>.  QPixmap is designed and optimized for
drawing; QImage is designed and optimized for I/O and for direct
pixel access/manipulation.  There are (slow) functions to convert
between QImage and QPixmp; <a href="qpixmap.html#c9">convertToImage</a>() and <a href="qpixmap.html#d1">convertFromImage</a>().
<p>One common use of the QPixmap class is to enable smooth updating of
widgets.  Whenever something complex needs to be drawn, you can use
a pixmap to obtain flicker-free drawing, like this:
<p><ol plain>
<li> Create a pixmap with the same size as the widget.
<li> Fill the pixmap with the widget background color.
<li> Paint the pixmap.
<li> <a href="qpaintdevice.html#b2">bitBlt</a>() the pixmap contents onto the widget.
</ol>
<p>Pixel data in a pixmap is internal and managed by the underlying
window system.  Pixels can only be accessed through <a href="qpainter.html">QPainter</a>
functions, through bitBlt(), and by converting the QPixmap to a
QImage.
<p>You can display a QPixmap on the screen easily using
e.g. <a href="qlabel.html#b7">QLabel::setPixmap</a>(), and all the <a href="qbutton.html">button classes</a> support pixmap use.
<p>There are also convenience functions to get and set single pixels
and to load and save the entire pixmap; these work by converting the
pixmap to a QImage internally.
<p>The QPixmap class is optimized by the use of <a href="shclass.html">implicit
sharing</a>, so it is very efficient to pass QPixmap objects as
arguments.
<p>See also:  <a href="qbitmap.html">QBitmap</a>, <a href="qimage.html">QImage</a>, <a href="qimageio.html">QImageIO</a> and <a href="shclass.html">Shared Classes</a>
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#QPixmap">qtimage/qtimage.cpp</a>
 <a href="grapher-grapher-cpp.html#QPixmap">grapher/grapher.cpp</a>
 <a href="desktop-desktop-cpp.html#QPixmap">desktop/desktop.cpp</a>
 <a href="hello-hello-cpp.html#QPixmap">hello/hello.cpp</a>
 <a href="movies-main-cpp.html#QPixmap">movies/main.cpp</a>
 <a href="picture-picture-cpp.html#QPixmap">picture/picture.cpp</a>
 <a href="xform-xform-cpp.html#QPixmap">xform/xform.cpp</a>
 <a href="application-application-cpp.html#QPixmap">application/application.cpp</a>
 <a href="menu-menu-cpp.html#QPixmap">menu/menu.cpp</a>
 <a href="qmag-qmag-cpp.html#QPixmap">qmag/qmag.cpp</a>
 <a href="widgets-widgets-cpp.html#QPixmap">widgets/widgets.cpp</a>

<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="a0"></a>QPixmap::QPixmap ()</h3>
<p>Constructs a null pixmap.
<p>See also:  <a href="qpixmap.html#b0">isNull</a>().
<h3 class="fn"><a name="a6"></a>QPixmap::QPixmap ( const QPixmap &amp; pixmap )</h3>
<p>Constructs a pixmap which is a copy of <em>pixmap.</em>
<h3 class="fn"><a name="a4"></a>QPixmap::QPixmap ( const char * fileName, const char * format, int conversion_flags )</h3>
<p>Constructs a pixmap from the file <em>fileName.</em> If the file does not
exist, or is of an unknown format, the pixmap becomes a null pixmap.
<p>The parameters are passed on to <a href="qpixmap.html#d4">load</a>().
<p>See also:  <a href="qpixmap.html#b0">isNull</a>(), <a href="qpixmap.html#d4">load</a>(), <a href="qpixmap.html#d6">loadFromData</a>(), <a href="qpixmap.html#d8">save</a>() and <a href="qpixmap.html#f3">imageFormat</a>().
<h3 class="fn"><a name="a3"></a>QPixmap::QPixmap ( const char * fileName, const char * format=0, ColorMode mode=Auto )</h3>
<p>Constructs a pixmap from the file <em>fileName.</em> If the file does not
exist, or is of an unknown format, the pixmap becomes a null pixmap.
<p>The parameters are passed on to <a href="qpixmap.html#d4">load</a>().
<p>See also:  <a href="qpixmap.html#b0">isNull</a>(), <a href="qpixmap.html#d4">load</a>(), <a href="qpixmap.html#d6">loadFromData</a>(), <a href="qpixmap.html#d8">save</a>() and <a href="qpixmap.html#f3">imageFormat</a>().
<h3 class="fn"><a name="a5"></a>QPixmap::QPixmap ( const char * xpm[] )</h3>
<p>Constructs a pixmap from <em>xpm,</em> which must be a valid XPM image.
<h3 class="fn"><a name="e6"></a>QPixmap::QPixmap ( int w, int h, const uchar * bits, bool isXbitmap ) <code>[protected]</code></h3>
<p>Constructs a monochrome pixmap which is initialized with the data in <em>bits.</em>
This constructor is protected and used by the <a href="qbitmap.html">QBitmap</a> class.
<h3 class="fn"><a name="a1"></a>QPixmap::QPixmap ( int w, int h, int depth=-1 )</h3>
<p>Constructs a pixmap with <em>w</em> width, <em>h</em> height and of <em>depth</em> bits per
pixels.
<p>The contents of the pixmap is uninitialized.
<p>The <em>depth</em> can be either 1 (monochrome) or the depth of the
current video mode.  If <em>depth</em> is negative, then the hardware
depth of the current video mode will be used.
<p>If either <em>width</em> or <em>height</em> is zero, a null pixmap is constructed.
<p>See also:  <a href="qpixmap.html#b0">isNull</a>().
<h3 class="fn"><a name="a2"></a>QPixmap::QPixmap ( const <a href="qsize.html">QSize</a> &amp; size, int depth=-1 )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn"><a name="a7"></a>QPixmap::~QPixmap ()</h3>
<p>Destroys the pixmap.
<h3 class="fn">bool <a name="d1"></a>QPixmap::convertFromImage ( const <a href="qimage.html">QImage</a> &amp; img, int conversion_flags )</h3>
<p>Converts an image and sets this pixmap. Returns TRUE if successful.
<p>The <em>conversion_flags</em> argument is a bitwise-OR from the following choices.
The options marked <em>(default)</em> are the choice if no other choice from the
list is included (they are zero):
<p><dl>
<dt>Color/Mono preference (ignored for <a href="qbitmap.html">QBitmap</a>)
<dd>
<ul>
<li> <code>AutoColor</code> (default) - If the <em>image</em> has <a href="qimage.html#c0">depth</a> 1 and contains only
black and white pixels, then the pixmap becomes monochrome.
<li> <code>ColorOnly</code> - The pixmap is dithered/converted to the
<a href="qpixmap.html#f6">native display depth</a>.
<li> <code>MonoOnly</code> - The pixmap becomes monochrome.  If necessary,
it is dithered using the chosen dithering algorithm.
</ul>
<dt>Dithering mode preference, for RGB channels
<dd>
<ul>
<li> <code>DiffuseDither</code> (default) - a high quality dither
<li> <code>OrderedDither</code> - a faster more ordered dither
<li> <code>ThresholdDither</code> - no dithering, closest color is used
</ul>
<dt>Dithering mode preference, for alpha channel
<dd>
<ul>
<li> <code>DiffuseAlphaDither</code> - a high quality dither
<li> <code>OrderedAlphaDither</code> - a faster more ordered dither
<li> <code>ThresholdAlphaDither</code> (default) - no dithering
</ul>
<dt>Color matching versus dithering preference
<dd>
<ul>
<li> <code>PreferDither</code> - always dither 32-bit images when
the image
is being converted to 8-bits.
This is the default when converting to a pixmap.
<li> <code>AvoidDither</code> - only dither 32-bit images if
the image
has more than 256 colours and it
is being converted to 8-bits.
This is the default when an image is converted
for the purpose of saving to a file.
</ul>
</dl>
<p>Passing 0 for <em>conversion_flags</em> gives all the default options.
<p>Note that even though a QPixmap with depth 1 behaves much like a
QBitmap, <a href="qpixmap.html#e5">isQBitmap</a>() returns FALSE.
<p>See also:  <a href="qpixmap.html#c9">convertToImage</a>(), <a href="qpixmap.html#e5">isQBitmap</a>(), <a href="qimage.html#e2">QImage::convertDepth</a>(), <a href="qpixmap.html#f6">defaultDepth</a>() and hasAlphaBuffer().
<p>Bugs and limitations:
<ul>
<li>Does not support 2 or 4 bit display hardware.
</ul>
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#convertFromImage">qtimage/qtimage.cpp</a>
<h3 class="fn">bool <a name="d0"></a>QPixmap::convertFromImage ( const <a href="qimage.html">QImage</a> &amp; img, ColorMode mode=Auto )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn"><a href="qimage.html">QImage</a> <a name="c9"></a>QPixmap::convertToImage () const</h3>
<p>Converts the pixmap to an image. Returns a null image if the operation
failed.
<p>If the pixmap has 1 bit depth, the returned image will also be 1
bits deep.  If the pixmap has 2-8 bit depth, the returned image
has 8 bit depth.  If the pixmap has greater than 8 bit depth, the
returned image has 32 bit depth.
<p>See also:  <a href="qpixmap.html#d1">convertFromImage</a>().
<p>Bugs and limitations:
<ul>
<li>Does not support 2 or 4 bit display hardware.
<li>Alpha masks on monochrome images are ignored.
</ul>
<p>Examples:
 <a href="qmag-qmag-cpp.html#convertToImage">qmag/qmag.cpp</a>
<h3 class="fn"><a href="qbitmap.html">QBitmap</a> <a name="c5"></a>QPixmap::createHeuristicMask ( bool clipTight = TRUE ) const</h3>
<p>Creates and returns a heuristic mask for this pixmap. It works by
selecting a color from one of the corners, then chipping away pixels of
that color, starting at all the edges.
<p>The mask may not be perfect but should be reasonable, so you can do
things like:
<pre>    pm-&gt;setMask( pm-&gt;createHeuristicMask() );
</pre>
<p>This function is slow because it involves transformation to a <a href="qimage.html">QImage</a>,
non-trivial computations and a transformation back to <a href="qbitmap.html">QBitmap</a>.
<p>See also:  <a href="qimage.html#e6">QImage::createHeuristicMask</a>().
<h3 class="fn">int <a name="f6"></a>QPixmap::defaultDepth () <code>[static]</code></h3>
<p>Returns the default pixmap depth, i.e. the depth a pixmap gets
if -1 is specified.
<p>See also:  <a href="qpixmap.html#b5">depth</a>().
<p>Examples:
 <a href="showimg-showimg-cpp.html#QPixmap::defaultDepth">showimg/showimg.cpp</a>
<h3 class="fn">QPixmap::Optimization <a name="f7"></a>QPixmap::defaultOptimization() <code>[static]</code></h3>
<p>Returns the default pixmap optimization setting.
<p>See also:  <a href="qpixmap.html#f8">setDefaultOptimization</a>(), <a href="qpixmap.html#e1">setOptimization</a>() and <a href="qpixmap.html#e0">optimization</a>().
<h3 class="fn">int <a name="b5"></a>QPixmap::depth () const</h3>
<p>Returns the depth of the image.
<p>The pixmap depth is also called bits per pixel (bpp) or bit planes
of a pixmap.  A null pixmap has depth 0.
<p>See also:  <a href="qpixmap.html#f6">defaultDepth</a>(), <a href="qpixmap.html#b0">isNull</a>() and <a href="qimage.html#e2">QImage::convertDepth</a>().
<h3 class="fn">void <a name="e4"></a>QPixmap::detach () <code>[virtual]</code></h3>
<p>Special-purpose function that detaches the pixmap from shared pixmap data.
<p>A pixmap is automatically detached by Qt whenever its contents is about
to change.  This is done in all QPixmap member functions that modify the
pixmap (<a href="qpixmap.html#b7">fill</a>(), <a href="qpixmap.html#c0">resize</a>(), <a href="qpixmap.html#d1">convertFromImage</a>(), <a href="qpixmap.html#d4">load</a>() etc.), in <a href="qpaintdevice.html#b2">bitBlt</a>()
for the destination pixmap and in <a href="qpainter.html#b0">QPainter::begin</a>() on a pixmap.
<p>It is possible to modify a pixmap without letting Qt know.
You can first obtain the <a href="qpaintdevice.html#a4">system-dependent handle</a>
and then call system-specific functions (for instance BitBlt under Windows)
that modifies the pixmap contents.  In this case, you can call detach()
to cut the pixmap loose from other pixmaps that share data with this one.
<p>detach() returns immediately if there is just a single reference or if
the pixmap has not been initialized yet.
<h3 class="fn">void <a name="b7"></a>QPixmap::fill ( const <a href="qcolor.html">QColor</a> &amp; fillColor=white )</h3>
<p>Fills the pixmap with the color <em>fillColor.</em>
<p>Examples:
 <a href="grapher-grapher-cpp.html#fill">grapher/grapher.cpp</a>
 <a href="desktop-desktop-cpp.html#fill">desktop/desktop.cpp</a>
 <a href="hello-hello-cpp.html#fill">hello/hello.cpp</a>
 <a href="xform-xform-cpp.html#fill">xform/xform.cpp</a>
<h3 class="fn">void <a name="b9"></a>QPixmap::fill ( const <a href="qwidget.html">QWidget</a> * widget, const <a href="qpoint.html">QPoint</a> &amp; ofs )</h3>
<p>Fills the pixmap with the widget's background color or pixmap.
If the background is empty, nothing is done.
<p>The <em>ofs</em> point is an offset in the widget.
<p>The point <em>ofs</em> is a point in the widget's coordinate system. The
pixmap's top left pixel will be mapped to the point <em>ofs</em> in the
widget. This is significant if the widget has a background pixmap,
otherwise the pixmap will simply be filled with the background color of
the widget.
<p>Example:
<pre>  void CuteWidget::paintEvent( <a href="qpaintevent.html">QPaintEvent</a> *e )
  {
    <a href="qrect.html">QRect</a> ur = e-&gt;<a href="qpaintevent.html#a1">rect</a>();               // rectangle to update

    <a href="qpixmap.html">QPixmap</a>  pix( ur.<a href="qrect.html#d5">size</a>() );          // Pixmap for double-buffering

    pix.<a href="qpixmap.html#b7">fill</a>( this, ur.<a href="qrect.html#c0">topLeft</a>() );     // fill with widget background

    <a href="qpainter.html">QPainter</a> p( &amp;pix );
    p.<a href="qpainter.html#f2">translate</a>( -ur.<a href="qrect.html#b2">x</a>(), -ur.<a href="qrect.html#b3">y</a>() );    // use widget coordinate system
                                        // when drawing on pixmap
    //    ... draw on pixmap ...

    p.<a href="qpainter.html#b2">end</a>();

    <a href="qpaintdevice.html#b2">bitBlt</a>( this, ur.<a href="qrect.html#c0">topLeft</a>(), &amp;pix );
  }
</pre>
<h3 class="fn">void <a name="b8"></a>QPixmap::fill ( const <a href="qwidget.html">QWidget</a> * widget, int xofs, int yofs )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">QPixmap <a name="g3"></a>QPixmap::grabWindow ( WId window, int x=0, int y=0, int w=-1, int h=-1 ) <code>[static]</code></h3>
<p>Grabs the contents of a window and makes a pixmap out of it.
Returns the pixmap.
<p>The argments <em>(x,y)</em> specify the offset in the window, while
<em>(w,h)</em> specify the width and height of the area to be copied.
<p>If <em>w</em> is negative, the function copies everything to the right
border of the window.  If <em>h</em> is negative, the function copies
everything to the bottom of the window.
<p>Note that grabWindows() grabs pixels from the screen, not from the
window.  This means that If there is another window partially or
entirely over the one you grab, you get pixels from the overlying
window too.
<p>The reason we use a window identifier and not a <a href="qwidget.html">QWidget</a> is to enable
grabbing of windows that are not part of the application.<p><strong>Warning:</strong> Grabbing an area outside the window, or screen, is not safe
in general.  This depends on the underlying window system.
<h3 class="fn">int <a name="b2"></a>QPixmap::height () const</h3>
<p>Returns the height of the pixmap.
<p>See also:  <a href="qpixmap.html#b1">width</a>(), <a href="qpixmap.html#b3">size</a>() and <a href="qpixmap.html#b4">rect</a>().
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#height">qtimage/qtimage.cpp</a>
 <a href="desktop-desktop-cpp.html#height">desktop/desktop.cpp</a>
 <a href="movies-main-cpp.html#height">movies/main.cpp</a>
 <a href="xform-xform-cpp.html#height">xform/xform.cpp</a>
<h3 class="fn">const char * <a name="f3"></a>QPixmap::imageFormat ( const char * fileName ) <code>[static]</code></h3>
<p>Returns a string that specifies the image format of the file <em>fileName,</em>
or null if the file cannot be read or if the format cannot be recognized.
<p>The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats.
<p>See also:  <a href="qpixmap.html#d4">load</a>() and <a href="qpixmap.html#d8">save</a>().
<h3 class="fn">bool <a name="b0"></a>QPixmap::isNull () const</h3>
<p>Returns TRUE if it is a null pixmap.
<p>A null pixmap has zero width, zero height and no contents.
You cannot draw in a null pixmap or <a href="qpaintdevice.html#b2">bitBlt</a>() anything to it.
<p>Resizing an existing pixmap to (0,0) makes a pixmap into a null
pixmap.
<p>See also:  <a href="qpixmap.html#c0">resize</a>().
<p>Examples:
 <a href="qmag-qmag-cpp.html#isNull">qmag/qmag.cpp</a>
<h3 class="fn">bool <a name="e5"></a>QPixmap::isQBitmap () const</h3>
<p>Returns TRUE if this is a <a href="qbitmap.html">QBitmap</a>, otherwise FALSE.
<h3 class="fn">bool <a name="d4"></a>QPixmap::load ( const char * fileName, const char * format, int conversion_flags )</h3>
<p>Loads a pixmap from the file <em>fileName.</em>
Returns TRUE if successful, or FALSE if the pixmap could not be loaded.
<p>If <em>format</em> is specified, the loader attempts to read the pixmap using the
specified format. If <em>format</em> is not specified (default),
the loader reads a few bytes from the header to guess the file format.
<p>See the <a href="qpixmap.html#d1">convertFromImage</a>() documentation for a description
of the <em>conversion_flags</em> argument.
<p>The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p>See also:  <a href="qpixmap.html#d6">loadFromData</a>(), <a href="qpixmap.html#d8">save</a>(), <a href="qpixmap.html#f3">imageFormat</a>(), <a href="qimage.html#f2">QImage::load</a>() and <a href="qimageio.html">QImageIO</a>.
<p>Examples:
 <a href="picture-picture-cpp.html#load">picture/picture.cpp</a>
 <a href="xform-xform-cpp.html#load">xform/xform.cpp</a>
 <a href="widgets-widgets-cpp.html#load">widgets/widgets.cpp</a>
<h3 class="fn">bool <a name="d3"></a>QPixmap::load ( const char * fileName, const char * format=0, ColorMode mode=Auto )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">bool <a name="d6"></a>QPixmap::loadFromData ( const uchar * buf, uint len, const char * format, int conversion_flags )</h3>
<p>Loads a pixmap from the binary data in <em>buf</em> (<em>len</em> bytes).
Returns TRUE if successful, or FALSE if the pixmap could not be loaded.
<p>If <em>format</em> is specified, the loader attempts to read the pixmap using the
specified format. If <em>format</em> is not specified (default),
the loader reads a few bytes from the header to guess the file format.
<p>See the <a href="qpixmap.html#d1">convertFromImage</a>() documentation for a description
of the <em>conversion_flags</em> argument.
<p>The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p>See also:  <a href="qpixmap.html#d4">load</a>(), <a href="qpixmap.html#d8">save</a>(), <a href="qpixmap.html#f3">imageFormat</a>(), <a href="qimage.html#f3">QImage::loadFromData</a>() and <a href="qimageio.html">QImageIO</a>.
<h3 class="fn">bool <a name="d7"></a>QPixmap::loadFromData ( <a href="qbytearray.html">QByteArray</a> buf, const char * format=0, int conversion_flags=0 )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">bool <a name="d5"></a>QPixmap::loadFromData ( const uchar * buf, uint len, const char * format=0, ColorMode mode=Auto )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">const <a href="qbitmap.html">QBitmap</a> * <a name="c2"></a>QPixmap::mask () const</h3>
<p>Returns the mask bitmap, or null if no mask has been set.
<p>See also:  <a href="qpixmap.html#c3">setMask</a>() and <a href="qbitmap.html">QBitmap</a>.
<h3 class="fn">int <a name="e7"></a>QPixmap::metric ( int m ) const <code>[virtual protected]</code></h3>
<p>Internal implementation of the virtual <a href="qpaintdevice.html#a8">QPaintDevice::metric</a>() function.
<p>Use the <a href="qpaintdevicemetrics.html">QPaintDeviceMetrics</a> class instead.
<p>Reimplemented from <a href="qpaintdevice.html#a8">QPaintDevice.</a>
<h3 class="fn">QPixmap &amp; <a name="a9"></a>QPixmap::operator= ( const <a href="qimage.html">QImage</a> &amp; image )</h3>
<p>Converts the image <em>image</em> to a pixmap that is assigned to this pixmap.
Returns a reference to the pixmap.
<p>See also:  <a href="qpixmap.html#d1">convertFromImage</a>().
<h3 class="fn">QPixmap &amp; <a name="a8"></a>QPixmap::operator= ( const QPixmap &amp; pixmap )</h3>
<p>Assigns the pixmap <em>pixmap</em> to this pixmap and returns a reference to
this pixmap.
<h3 class="fn">QPixmap::Optimization <a name="e0"></a>QPixmap::optimization() const</h3>
<p>Returns the optimization setting for this pixmap.
<p>The default optimization setting is <code>QPixmap::NormalOptim.</code> You may
change this settings in two ways:
<ul>
<li> Call <a href="qpixmap.html#f8">setDefaultOptimization</a>() to set the default optimization
for all new pixmaps.
<li> Call <a href="qpixmap.html#e1">setOptimization</a>() to set a the optimization for individual
pixmaps.
</ul>
<p>See also:  <a href="qpixmap.html#e1">setOptimization</a>(), <a href="qpixmap.html#f8">setDefaultOptimization</a>() and <a href="qpixmap.html#f7">defaultOptimization</a>().
<h3 class="fn"><a href="qrect.html">QRect</a> <a name="b4"></a>QPixmap::rect () const</h3>
<p>Returns the enclosing rectangle (0,0,<a href="qpixmap.html#b1">width</a>(),<a href="qpixmap.html#b2">height</a>()) of the pixmap.
<p>See also:  <a href="qpixmap.html#b1">width</a>(), <a href="qpixmap.html#b2">height</a>() and <a href="qpixmap.html#b3">size</a>().
<p>Examples:
 <a href="xform-xform-cpp.html#rect">xform/xform.cpp</a>
<h3 class="fn">void <a name="c0"></a>QPixmap::resize ( int w, int h )</h3>
<p>Resizes the pixmap to <em>w</em> width and <em>h</em> height.  If either <em>w</em>
or <em>h</em> is less than 1, the pixmap becomes a null pixmap.
<p>If both <em>w</em> and <em>h</em> are greater than 0, a valid pixmap is created.
New pixels will be uninitialized (random) if the pixmap is expanded.
<p>Examples:
 <a href="grapher-grapher-cpp.html#resize">grapher/grapher.cpp</a>
 <a href="desktop-desktop-cpp.html#resize">desktop/desktop.cpp</a>
<h3 class="fn">void <a name="c1"></a>QPixmap::resize ( const <a href="qsize.html">QSize</a> &amp; size )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">bool <a name="d8"></a>QPixmap::save ( const char * fileName, const char * format ) const</h3>
<p>Saves the pixmap to the file <em>fileName,</em> using the image file format
<em>format.</em>  Returns TRUE if successful, or FALSE if the pixmap could not
be saved.
<p>See also:  <a href="qpixmap.html#d4">load</a>(), <a href="qpixmap.html#d6">loadFromData</a>(), <a href="qpixmap.html#f3">imageFormat</a>(), <a href="qimage.html#f5">QImage::save</a>() and <a href="qimageio.html">QImageIO</a>.
<p>Examples:
 <a href="qmag-qmag-cpp.html#save">qmag/qmag.cpp</a>
<h3 class="fn">bool <a name="c4"></a>QPixmap::selfMask () const</h3>
<p>Returns TRUE if the pixmap's mask is identical to the pixmap
itself.
<p>See also:  <a href="qpixmap.html#c2">mask</a>().
<h3 class="fn">int <a name="d9"></a>QPixmap::serialNumber () const</h3>
<p>Returns a number that uniquely identifies this QPixmap object. The
serial number is very useful for caching.
<p>See also:  <a href="qpixmapcache.html">QPixmapCache</a>.
<h3 class="fn">void <a name="f8"></a>QPixmap::setDefaultOptimization ( Optimization optimization ) <code>[static]</code></h3>
<p>Sets the default pixmap optimization.
<p>All <em>new</em> pixmaps that are created will use this default optimization.
You may also set optimization for individual pixmaps using the
<a href="qpixmap.html#e1">setOptimization</a>() function.
<p>The initial default optimization setting is <code>QPixmap::Normal.</code>
<p>See also:  <a href="qpixmap.html#f7">defaultOptimization</a>(), <a href="qpixmap.html#e1">setOptimization</a>() and <a href="qpixmap.html#e0">optimization</a>().
<h3 class="fn">void <a name="c3"></a>QPixmap::setMask ( const <a href="qbitmap.html">QBitmap</a> &amp; mask )</h3>
<p>Sets a mask bitmap.
<p>The <em>mask</em> bitmap defines the clip mask for this pixmap. Every pixel in
<em>mask</em> corresponds to a pixel in this pixmap. Pixel value 1 means opaque
and pixel value 0 means transparent. The mask must have the same size as
this pixmap.
<p>Setting a <a href="qpixmap.html#b0">null</a> mask resets the mask,
<p>See also:  <a href="qpixmap.html#c2">mask</a>(), <a href="qpixmap.html#c5">createHeuristicMask</a>() and <a href="qbitmap.html">QBitmap</a>.
<h3 class="fn">void <a name="e1"></a>QPixmap::setOptimization ( Optimization optimization )</h3>
<p>Sets pixmap drawing optimization for this pixmap.
<p>The optimization setting affects pixmap operations, in particular
drawing of transparent pixmaps (<a href="qpaintdevice.html#b2">bitBlt</a>() a pixmap with a mask set) and
pixmap transformations (the <a href="qpixmap.html#c7">xForm</a>() function).
<p>Pixmap optimization involves keeping intermediate results in a cache
buffer and use the data in the cache to speed up bitBlt() and xForm().
The cost is more memory consumption, up to twice as much as an
unoptimized pixmap.
<p>The <em>optimization</em> parameter can be:
<ul>
<li> <code>QPixmap::NoOptim,</code> avoid optimization. Little or no caching is
done. Use this setting if memory is scarce and the speed of pixmap
operations is not critical to your application.
<li> <code>QPixmap::NormalOptim,</code> normal optimization to make pixmap drawing
faster. This option is the default and is suitable for most purposes.
<li> <code>QPixmap::BestOptim,</code> heavily optimized pixmap drawing. Use this
option for pixmap drawn extremely frequently.
</ul>
<p>Use the <a href="qpixmap.html#f8">setDefaultOptimization</a>() to change the default optimization
for all new pixmaps.
<p>See also:  <a href="qpixmap.html#e0">optimization</a>(), <a href="qpixmap.html#f8">setDefaultOptimization</a>() and <a href="qpixmap.html#f7">defaultOptimization</a>().
<h3 class="fn"><a href="qsize.html">QSize</a> <a name="b3"></a>QPixmap::size () const</h3>
<p>Returns the size of the pixmap.
<p>See also:  <a href="qpixmap.html#b1">width</a>(), <a href="qpixmap.html#b2">height</a>() and <a href="qpixmap.html#b4">rect</a>().
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#size">qtimage/qtimage.cpp</a>
 <a href="movies-main-cpp.html#size">movies/main.cpp</a>
<h3 class="fn"><a href="qwmatrix.html">QWMatrix</a> <a name="g4"></a>QPixmap::trueMatrix ( const <a href="qwmatrix.html">QWMatrix</a> &amp; matrix, int w, int h ) <code>[static]</code></h3>
<p>Returns the actual matrix used for transforming a pixmap with <em>w</em>
width and <em>h</em> height.
<p>When transforming a pixmap with <a href="qpixmap.html#c7">xForm</a>(), the transformation matrix
is internally adjusted to compensate for unwanted translation,
i.e. xForm() returns the smallest pixmap containing all transformed
points of the original pixmap.
<p>This function returns the modified matrix, which maps points
correctly from the original pixmap into the new pixmap.
<p>See also:  <a href="qpixmap.html#c7">xForm</a>() and <a href="qwmatrix.html">QWMatrix</a>.
<h3 class="fn">int <a name="b1"></a>QPixmap::width () const</h3>
<p>Returns the width of the pixmap.
<p>See also:  <a href="qpixmap.html#b2">height</a>(), <a href="qpixmap.html#b3">size</a>() and <a href="qpixmap.html#b4">rect</a>().
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#width">qtimage/qtimage.cpp</a>
 <a href="desktop-desktop-cpp.html#width">desktop/desktop.cpp</a>
 <a href="movies-main-cpp.html#width">movies/main.cpp</a>
 <a href="xform-xform-cpp.html#width">xform/xform.cpp</a>
<h3 class="fn">QPixmap <a name="c7"></a>QPixmap::xForm ( const <a href="qwmatrix.html">QWMatrix</a> &amp; matrix ) const</h3>
<p>Returns a copy of the pixmap that is transformed using <em>matrix.</em>
<p>Qt uses this function to implement rotated text on window systems
that do not support such complex features.
<p>Example of how to manually draw a rotated text at (100,200) in a widget:
<pre>    char    *str = "Trolls R Qt";       // text to be drawn
    <a href="qfont.html">QFont</a>    f( "Charter", 24 );        // use Charter 24pt font
    <a href="qpixmap.html">QPixmap</a>  pm( 8, 8 );
    <a href="qpainter.html">QPainter</a> p;
    <a href="qrect.html">QRect</a>    r;                         // text bounding rectangle
    <a href="qpoint.html">QPoint</a>   bl;                        // text baselink position

    p.<a href="qpainter.html#b0">begin</a>( &amp;pm );                     // first get the bounding
    p.<a href="qpainter.html#c2">setFont</a>( f );                     //   text rectangle
    r = p.<a href="qpainter.html#b9">fontMetrics</a>().boundingRect(str);
    bl = -r.<a href="qrect.html#c0">topLeft</a>();                  // get baseline position
    p.<a href="qpainter.html#b2">end</a>();

    pm.<a href="qpixmap.html#c0">resize</a>( r.<a href="qrect.html#d5">size</a>() );              // resize to fit the text
    pm.<a href="qpixmap.html#b7">fill</a>( white );                   // fills pm with white
    p.<a href="qpainter.html#b0">begin</a>( &amp;pm );                     // begin painting pm
    p.<a href="qpainter.html#c2">setFont</a>( f );                     // set the font
    p.<a href="qpainter.html#c4">setPen</a>( blue );                   // set blue text color
    p.<a href="qpainter.html#l4">drawText</a>( bl, str );              // draw the text
    p.<a href="qpainter.html#b2">end</a>();                            // painting done

    <a href="qwmatrix.html">QWMatrix</a> m;                         // transformation matrix
    m.<a href="qwmatrix.html#b8">rotate</a>( -33.4 );                  // rotate coordinate system
    <a href="qpixmap.html">QPixmap</a> rp = pm.<a href="qpixmap.html#c7">xForm</a>( m );         // rp is rotated pixmap

    <a href="qwmatrix.html">QWMatrix</a> t = QPixmap::trueMatrix( m, pm.<a href="qpixmap.html#b1">width</a>(), pm.<a href="qpixmap.html#b2">height</a>() );
    int x, y;
    t.<a href="qwmatrix.html#a9">map</a>( bl.<a href="qpoint.html#a3">x</a>(),bl.<a href="qpoint.html#a4">y</a>(), &amp;x,&amp;y );      // get pm's baseline pos in rp

    <a href="qpaintdevice.html#b2">bitBlt</a>( myWidget, 100-x, 200-y,     // blt rp into a widget
            &amp;rp, 0, 0, -1, -1 );
</pre>
<p>This example outlines how Qt implements rotated text under X11.
The font calculation is the most tedious part. The rotation itself is
only 3 lines of code.
<p>If you want to draw rotated text, you do not have to implement all the
code above. The code below does exactly the same thing as the example
above, except that it uses a <a href="qpainter.html">QPainter</a>.
<p><pre>    char    *str = "Trolls R Qt";       // text to be drawn
    <a href="qfont.html">QFont</a>    f( "Charter", 24 );        // use Charter 24pt font
    <a href="qpainter.html">QPainter</a> p;

    p.<a href="qpainter.html#b0">begin</a>( myWidget );
    p.<a href="qpainter.html#f2">translate</a>( 100, 200 );            // translates coord system
    p.<a href="qpainter.html#f5">rotate</a>( -33.4 );                  // rotates it counterclockwise
    p.<a href="qpainter.html#c2">setFont</a>( f );
    p.<a href="qpainter.html#l4">drawText</a>( 0, 0, str );
    p.<a href="qpainter.html#b2">end</a>();
</pre>
<p>See also:  <a href="qpixmap.html#g4">trueMatrix</a>(), <a href="qwmatrix.html">QWMatrix</a> and <a href="qpainter.html#f1">QPainter::setWorldMatrix</a>().
<p>Bugs and limitations:
<ul>
<li>2 and 4 bits pixmaps are not supported.
</ul>
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#xForm">qtimage/qtimage.cpp</a>
 <a href="desktop-desktop-cpp.html#xForm">desktop/desktop.cpp</a>
 <a href="movies-main-cpp.html#xForm">movies/main.cpp</a>
 <a href="qmag-qmag-cpp.html#xForm">qmag/qmag.cpp</a>
<hr><h2>Related Functions</h2>
<h3><a href="qdatastream.html">QDataStream</a> &amp; <a name="f4"></a>operator&lt;&lt; (<a href="qdatastream.html">QDataStream</a> &amp; s, const QPixmap &amp; pixmap)</h3>
<p>Writes a pixmap to the stream as a BMP image.
<p>See also:  <a href="qpixmap.html#d8">QPixmap::save</a>().

<h3><a href="qdatastream.html">QDataStream</a> &amp; <a name="f5"></a>operator&gt;&gt; (<a href="qdatastream.html">QDataStream</a> &amp; s, QPixmap &amp; pixmap)</h3>
<p>Reads a pixmap from the stream.
<p>See also:  <a href="qpixmap.html#d4">QPixmap::load</a>().

<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses 
<a href="http://www.troll.no">www.troll.no</a>):<br>
<form method=post action="http://www.troll.no/search.cgi">
<input type=hidden name="version" value="1.44"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-99
<a href="troll.html">Troll Tech</a>, all rights reserved.
<p>
It was generated from the following files:
<ul>
<li>qpixmap.h: 1998/10/08
<li>qpixmap.cpp: 1998/07/06
</ul>
<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 1999 Troll Tech<td><a href="trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 1.45</div>
</table></div></address></body></html>
